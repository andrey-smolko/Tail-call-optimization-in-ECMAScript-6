# 2.2 Хвостовые вызовы в инструкциях

Для инструкций применяются следующие правила.

Только эти составные инструкции могут содержать хвостовые вызовы:

* Блоки (ограничены {}, с инструкцией метки или без нее)
* if: либо в ветвях “then” или “else”.
* do-while, while, for: в теле цикла.
* switch: в блоке выбора.
* try-catch: только в блоке catch. В контексте блока try содержится блок catch и поэтому он не может быть оптимизирован.
* try-finally, try-catch-finally: только в блоке finally, который находится в контексте для других блоков, поэтому они не могут быть оптимизированы.

Из всех одиночных инструкций только "return" может может содержать хвостовой вызов. Все остальные инструкции имеют контекст, который нельзя оптимизировать. Следующая инструкция содержит хвостовой вызов, если "expr" содержит его.

```return «expr»;```

## 2.3 Оптимизация хвостовых вызовов может производиться только в строгом режиме

В нестрогом режиме (non-strict mode) большинство движков имеет следующие два свойства, которые позволяют проверять стек вызовов:

* func.arguments: содержит аргументы последнего вызова функции func.
* func.caller: ссылается на функцию, которая последняя вызывала func.

При оптимизации хвостовых вызовов эти свойства не работают, поскольку информация, на которую они полагаются, может быть удалена. Поэтому строгий режим запрещает эти свойства (как описано в спецификации) и оптимизация хвостовых вызовов работает только в строгом режиме.

### 2.4 Подводный камень: вызов единственной функции никогда не находится в хвостовой позиции

Вызов функции bar() в следующем коде не находится в хвостовой позиции:

```js

function foo() {
    bar(); // this is not a tail call in JS
}

```

Причина в том, что последнее действие функции foo() не является вызовом функции bar(), оно (неявно) возвращает undefined. Другими словами, foo() ведет себя так:

```js

function foo() {
    bar();
    return undefined;
}

```

Функции, вызывающие foo() всегда ощидают возврат undefined. Если bar() должен был вернуть результат за foo() из-за оптимизации хвостового вызова, это могло бы изменить поведение foo.

Поэтому, если мы хотим, чтобы bar() был хвостовым вызовом, необходимо изменить foo() следующим образом:

```js

function foo() {
    return bar(); // tail call
}

```