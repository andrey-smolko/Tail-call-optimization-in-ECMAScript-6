# 1.2 Оптимизация хвостовых вызовов

```js
function id(x) {
    return x; // (A)
}
function f(a) {
    let b = a + 1;
    return id(b); // (B)
}
console.log(f(2)); // (C)
```

Если взглянуть на предыдущий раздел, то можно увидеть, что одни шаг лишний - это шаг 5. Все, что происходит в строке B - это передача значения, возвращаемого id(), в строку C. В идеале функция id() может сделать это сама, и промежуточный этап можно опустить.

Мы можем добиться такого поведения по-другому реализовав вызов функции в строке B. Перед вызовом стек выглядит следующим образом:

![pic6](http://2ality.com/2015/06/tail-call-optimization/stack_frames_2.jpg)

Если рассматривать вызов, то можно заметить, что это последнее действие в f(). Как только id() будет выполнена, единственным оставшимся действием, выполняемым f(), будет передача результата id() в функцию, вызывающую f(). Поэтому переменные f больше не нужны, и ее стековый кадр может быть удален перед следуюшим вызовом. Адрес возврата, передающийся в id(), это адрес возврата f, строка C. Во время выполнения id() стек выглядит следующим образом:

![pic7](http://2ality.com/2015/06/tail-call-optimization/stack_frames_2_tco.jpg)

Тогда id() возвращает значение 3. Можно сказать, что функция id возвращает значение за функцию f, потому что id передает значение в функцию вызываюшую f, строка C.

Итак, сделаем вывод. Вызов функции в строке B является *хвостовым вызовом*. Такой вызов может быть выполнен с нулевым ростом стека. Чтобы узнать, является ли вызов функции хвостовым, мы должны проверить, находится ли эта функция в хвостовой позиции (т.е. является ли последним действием функции). Как это делается рассмотрено в следующем разделе.