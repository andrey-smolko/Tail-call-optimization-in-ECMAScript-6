# 2. Как проверить, находится ли вызов функции в хвостовой позиции

В предыдущем разделе было выяснено, что хвостовые вызовы - это вызовы функций, которые могут выполняться более эффективно. Но что считается хвостовым вызовом?

Во-первых, способ, которым вы вызываете функцию, не имеет значения. Следующие вызовы могут быть оптимизированы, если они появятся в хвостовой позиции:

* Функциональный вызов: func(···)
* Вызывается как метод объекта: obj.method(···)
* Прямой вызов через call(): func.call(···)
* Прямой вызов через apply(): func.apply(···)

## 2.1 Хвостовые вызовы в выражениях

Стрелочные функции могут содержать выражения в качестве тела. По этой причине для оптимизации хвостовых вызовов мы должны выяснить, находятся ли вызовы функций в хвостовых позициях внутри выражений. Только следующие выражения могут содержать хвостовые вызовы:

* Условный оператор (? :)
* Логический оператор ИЛИ (||)
* Логический оператор И (&&)
* Оператор запятая (,)

Давайте рассмотрим примеры каждого из них.

### Условный оператор (? :)

```const a = x => x ? f() : g();```

Обе функции f() и g() находятся в хвостовой позиции.

### Логический оператор ИЛИ (||)

```const a = () => f() || g();```

f() не находится в хвостовом позиции, в отличии от g(). Чтобы понять, почему, взгляните на следующий код, который эквивалентен предыдущему коду:

```js
const a = () => {
    let fResult = f(); // not a tail call
    if (fResult) {
        return fResult;
    } else {
        return g(); // tail call
    }
};
```

Результат логического оператора ИЛИ зависит от результата f(), поэтому этот вызов функции не находится в хвостовой позиции (функция, вызывающая f(), делает что-то с ней, кроме возврата). Однако g() находится в хвостовой позиции.

### Логический оператор И

```const a = () => f() && g();```

f() не находится в хвостовой позиции, в отличии от g(). Чтобы понять, почему, взгляните на следующий код, который эквивалентен предыдущему коду:

```js

const a = () => {
    let fResult = f(); // not a tail call
    if (!fResult) {
        return fResult;
    } else {
        return g(); // tail call
    }
};

```

Результат логического оператора И зависит от результата f(), поэтому этот вызов функции не находится в хвостовой позиции (функция, вызывающая f(), делает что-то с ней, кроме возврата). Однако g() находится в хвостовой позиции.

### Оператор запятая (,)

```const a = () => (f() , g());```

f() не находится в хвостовой позиции, в отличии от g(). Чтобы понять, почему, взгляните на следующий код, который эквивалентен предыдущему коду:

```js
const a = () => {
    f();
    return g();
}
```